// ============================================================
// ‚úÖ src/components/admin/ProductManagement.jsx ‚Äî FINAL STABLE VERSION
// ============================================================
import React, { useState, useEffect, useCallback } from "react";
import { useUser } from "../../contexts/UserContext";
import { fetchWithAuth } from "../../utils/fetchWithAuth";
import "../AdminDashboard.css";

const API_URL =
  process.env.NEXT_PUBLIC_API_URL || "https://bookstore-0hqj.onrender.com";

const ProductManagement = () => {
  const { user } = useUser();
  const [products, setProducts] = useState([]);
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isEditing, setIsEditing] = useState(false);
  const [currentProduct, setCurrentProduct] = useState(null);

  const [formData, setFormData] = useState({
    name: "",
    description: "",
    category: "",
    subcategory: "",
    seriesTitle: "",
    volumeNumber: "",
    publisher: "",
    slug: "",
    author: "",
    authorBio: "",
    publicationDate: "",
    age: "",
    variants: [],
    status: "Active", // ‚úÖ Added status field
  });

  useEffect(() => {
    if (user?.token) {
      fetchProducts();
      fetchCategories();
    }
  }, [user]);

  const fetchProducts = async () => {
    try {
      setLoading(true);
      const res = await fetchWithAuth(`${API_URL}/api/admin/products`, {}, user.token);
      const data = await res.json();
      setProducts(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error("‚ùå Fetch products failed:", err);
      setProducts([]);
    } finally {
      setLoading(false);
    }
  };

  const fetchCategories = async () => {
    try {
      const res = await fetch(`${API_URL}/api/categories`);
      const data = await res.json();
      setCategories(data);
    } catch (err) {
      console.error("‚ùå Fetch categories failed:", err);
    }
  };

  const generateSlug = (name, volumeNumber) => {
    const base = name
      ?.toLowerCase()
      ?.trim()
      ?.replace(/[^\w\s-]/g, "")
      ?.replace(/\s+/g, "-")
      ?.replace(/--+/g, "-");
    return volumeNumber ? `${base}-vol-${volumeNumber}` : base;
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => {
      const updated = { ...prev, [name]: value };
      if (name === "name" || name === "volumeNumber") {
        updated.slug = generateSlug(updated.name, updated.volumeNumber);
      }
      return updated;
    });
  };

  const selectedCategory = categories.find((cat) => cat.slug === formData.category);
  const subcategories = selectedCategory?.subcategories || [];

  const addVariant = useCallback(() => {
    setFormData((prev) => ({
      ...prev,
      variants: [
        ...prev.variants,
        {
          format: "Paperback",
          price: "",
          countInStock: "",
          isbn: "",
          trimSize: "",
          pages: "",
          mainImage: null,
          mainPreview: null,
          albumImages: [],
        },
      ],
    }));
  }, []);

  const removeVariant = useCallback((index) => {
    setFormData((prev) => {
      const updated = [...prev.variants];
      updated.splice(index, 1);
      return { ...prev, variants: updated };
    });
  }, []);

  const updateVariant = useCallback((index, field, value) => {
    setFormData((prev) => {
      const updated = prev.variants.map((variant, i) =>
        i === index ? { ...variant, [field]: value } : variant
      );
      return { ...prev, variants: updated };
    });
  }, []);

  const handleVariantMainImage = useCallback((index, file) => {
    if (!file || !(file instanceof File)) return;
    setFormData((prev) => {
      const updated = prev.variants.map((variant, i) =>
        i === index
          ? { ...variant, mainImage: file, mainPreview: URL.createObjectURL(file) }
          : variant
      );
      return { ...prev, variants: updated };
    });
  }, []);

  const handleVariantAlbumImages = useCallback((index, files) => {
    if (!files || files.length === 0) return;
    setFormData((prev) => {
      const updated = [...prev.variants];
      const newImages = Array.from(files).map((file) => ({
        file,
        preview: URL.createObjectURL(file),
      }));
      updated[index].albumImages = [...(updated[index].albumImages || []), ...newImages];
      return { ...prev, variants: updated };
    });
  }, []);

  const removeAlbumImage = (variantIndex, imageIndex) => {
    setFormData((prev) => {
      const updated = [...prev.variants];
      updated[variantIndex].albumImages.splice(imageIndex, 1);
      return { ...prev, variants: updated };
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const url = isEditing
        ? `${API_URL}/api/admin/products/${currentProduct._id}`
        : `${API_URL}/api/admin/products`;
      const method = isEditing ? "PUT" : "POST";
      const data = new FormData();

      Object.keys(formData).forEach((key) => {
        if (key !== "variants") data.append(key, formData[key]);
      });

      formData.variants.forEach((v, idx) => {
        if (v.mainImage instanceof File) {
          data.append(`variantMainImages_${idx}`, v.mainImage);
        }
        v.albumImages.forEach((imgObj) => {
          if (imgObj.file instanceof File) {
            data.append(`variantAlbumImages_${idx}`, imgObj.file);
          }
        });
      });

      const serializedVariants = formData.variants.map((v) => ({
        format: v.format,
        price: v.price,
        countInStock: v.countInStock,
        isbn: v.isbn,
        trimSize: v.trimSize,
        pages: v.pages,
        mainImage:
          v.mainImage instanceof File
            ? null
            : v.mainPreview || v.mainImage || "",
        albumImages: v.albumImages.map((img) => img.preview || ""),
      }));

      data.append("variants", JSON.stringify(serializedVariants));

      const res = await fetchWithAuth(url, { method, body: data }, user.token);
      if (!res.ok) throw new Error("Failed to save product");

      await fetchProducts();
      resetForm();
      alert(isEditing ? "‚úÖ Product updated!" : "‚úÖ Product created!");
    } catch (err) {
      console.error("‚ùå Save failed:", err);
      alert("Error saving product. Check console for details.");
    }
  };

  const handleEdit = (p) => {
    setCurrentProduct(p);
    setFormData({
      name: p.name,
      description: p.description,
      category: p.category,
      subcategory: p.subcategory,
      seriesTitle: p.seriesTitle || "",
      volumeNumber: p.volumeNumber || "",
      publisher: p.publisher || "",
      slug: p.slug || "",
      author: p.author || "",
      authorBio: p.authorBio || "",
      publicationDate: p.publicationDate?.split("T")[0] || "",
      age: p.age || "",
      variants:
        p.variants?.map((v) => ({
          format: v.format,
          price: v.price,
          countInStock: v.countInStock,
          isbn: v.isbn,
          trimSize: v.trimSize,
          pages: v.pages,
          mainImage: null,
          mainPreview: v.mainImage || null,
          albumImages: v.albumImages?.map((url) => ({ preview: url })) || [],
        })) || [],
      status: p.status || "Active", // ‚úÖ added
    });
    setIsEditing(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const handleDelete = async (id) => {
    if (!window.confirm("Delete this product?")) return;
    try {
      const res = await fetchWithAuth(
        `${API_URL}/api/admin/products/${id}`,
        { method: "DELETE" },
        user.token
      );
      if (!res.ok) throw new Error("Failed to delete");
      fetchProducts();
      alert("üóëÔ∏è Product deleted successfully!");
    } catch (err) {
      console.error("‚ùå Delete failed:", err);
      alert("Failed to delete product.");
    }
  };

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
      category: "",
      subcategory: "",
      seriesTitle: "",
      volumeNumber: "",
      publisher: "",
      slug: "",
      author: "",
      authorBio: "",
      publicationDate: "",
      age: "",
      variants: [],
      status: "Active", // ‚úÖ added
    });
    setIsEditing(false);
    setCurrentProduct(null);
  };

  if (loading) return <div className="loading">Loading products...</div>;

  return (
    <div className="admin-container">
      <div className="product-form-container">
        <h2>{isEditing ? "Edit Product" : "Add New Product"}</h2>
        <form onSubmit={handleSubmit} className="product-form">
          {[{ name: "name", label: "Product Name", type: "text", required: true },
            { name: "slug", label: "Slug (auto)", type: "text" },
            { name: "seriesTitle", label: "Series Title", type: "text" },
            { name: "volumeNumber", label: "Volume Number", type: "number" },
            { name: "publisher", label: "Publisher", type: "text" },
            { name: "author", label: "Author", type: "text" },
            { name: "publicationDate", label: "Publication Date", type: "date" },
            { name: "age", label: "Age Range", type: "text" }].map((field) => (
            <div className="form-group floating-label" key={field.name}>
              <input
                type={field.type}
                name={field.name}
                value={formData[field.name]}
                required={field.required}
                onChange={handleInputChange}
              />
              <label className={formData[field.name] ? "filled" : ""}>
                {field.label}
              </label>
            </div>
          ))}

          {/* ‚úÖ Product Status Selector */}
          <div className="form-group">
            <label>Status</label>
            <select
              name="status"
              value={formData.status}
              onChange={handleInputChange}
            >
              <option value="Active">Active</option>
              <option value="Inactive">Inactive</option>
              <option value="Out of Stock">Out of Stock</option>
            </select>
          </div>

          <div className="form-group full-width">
            <label>Description</label>
            <textarea
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              required
            />
          </div>

          <div className="form-group full-width">
            <label>Product Variants</label>
            <div className="variants-section">
              {formData.variants.map((v, idx) => (
                <div key={idx} className="variant-row">
                  <select
                    value={v.format}
                    onChange={(e) => updateVariant(idx, "format", e.target.value)}
                  >
                    <option value="Paperback">Paperback</option>
                    <option value="Hardcover">Hardcover</option>
                  </select>
                  <input
                    type="number"
                    placeholder="Price"
                    value={v.price}
                    onChange={(e) => updateVariant(idx, "price", e.target.value)}
                  />
                  <input
                    type="number"
                    placeholder="Stock"
                    value={v.countInStock}
                    onChange={(e) =>
                      updateVariant(idx, "countInStock", e.target.value)
                    }
                  />
                  <input
                    type="text"
                    placeholder="ISBN"
                    value={v.isbn}
                    onChange={(e) => updateVariant(idx, "isbn", e.target.value)}
                  />
                  <label>Main Image</label>
                  <input
                    type="file"
                    accept="image/*"
                    onChange={(e) =>
                      handleVariantMainImage(idx, e.target.files[0])
                    }
                  />
                  {v.mainPreview && (
                    <img
                      src={v.mainPreview}
                      alt="Main Preview"
                      style={{ width: "200px", borderRadius: "8px", marginTop: "8px" }}
                    />
                  )}
                  <label>Album Images</label>
                  <input
                    type="file"
                    multiple
                    accept="image/*"
                    onChange={(e) =>
                      handleVariantAlbumImages(idx, e.target.files)
                    }
                  />
                  <div className="album-preview">
                    {v.albumImages.map((img, i) => (
                      <div key={i} className="album-item">
                        <img src={img.preview} alt="Album" className="album-thumb" />
                        <button
                          type="button"
                          className="remove-btn"
                          onClick={() => removeAlbumImage(idx, i)}
                        >
                          ‚ùå
                        </button>
                      </div>
                    ))}
                  </div>
                  <button
                    type="button"
                    className="btn-delete"
                    onClick={() => removeVariant(idx)}
                  >
                    Remove Variant
                  </button>
                </div>
              ))}
              <button type="button" className="btn-submit" onClick={addVariant}>
                + Add Variant
              </button>
            </div>
          </div>

          <div className="form-buttons">
            <button type="submit" className="btn-submit">
              {isEditing ? "Update Product" : "Add Product"}
            </button>
            {isEditing && (
              <button type="button" className="btn-cancel" onClick={resetForm}>
                Cancel
              </button>
            )}
          </div>
        </form>
      </div>

      <div className="products-list-container">
        <h2>Product List</h2>
        {products.length === 0 ? (
          <div className="no-products">No products found.</div>
        ) : (
          <table className="products-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Category</th>
                <th>Variants</th>
                <th>Stock</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {products.map((p) => (
                <tr key={p._id}>
                  <td>{p.name}</td>
                  <td>{p.category}</td>
                  <td>
                    {p.variants
                      ?.map((v) => `${v.format}: ‚Ç±${v.price}`)
                      .join(" | ")}
                  </td>
                  <td>
                    {p.variants?.reduce(
                      (sum, v) => sum + (v.countInStock || 0),
                      0
                    )}
                  </td>
                  <td>{p.status}</td>
                  <td className="actions">
                    <button className="btn-edit" onClick={() => handleEdit(p)}>
                      Edit
                    </button>
                    <button
                      className="btn-delete"
                      onClick={() => handleDelete(p._id)}
                    >
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
};

export default ProductManagement;
